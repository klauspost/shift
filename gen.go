// +build generate

//go:generate go run $GOFILE && gofmt -w generated.go

package main

import (
	"os"
	"strings"
)

func main() {
	f, err := os.Create("generated.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	value := []string{"uint8", "uint16", "uint32", "uint64", "uint", "int8", "int16", "int32", "int64", "int"}
	shift := []string{"uint8", "uint16", "uint32", "uint64", "uint"}
	imports := []string{}
	f.WriteString(`// Code generated by go generate gen.go. DO NOT EDIT.

package shift

`)
	if len(imports) > 0 {
		f.WriteString("import (\n")
		for _, imp := range imports {
			f.WriteString("\t\"" + imp + "\"\n")
		}
		f.WriteString(")\n\n")
	}

	template := `
// Left$VALTYPECAP$$SHIFTYPECAP$ is x << n but where n is always less than the number of bits in $VALTYPE$.
// This assumption is not checked.
func Left$VALTYPECAP$$SHIFTYPECAP$(x $VALTYPE$, n $SHIFTYPE$) $VALTYPE$ {
	return x << (n & mask$VALTYPECAP$$SHIFTYPECAP$)
}

// Right$VALTYPECAP$$SHIFTYPECAP$ is x >> n but where n is always less than the number of bits in $VALTYPE$.
// This assumption is not checked.
func Right$VALTYPECAP$$SHIFTYPECAP$(x $VALTYPE$, n $SHIFTYPE$) $VALTYPE$ {
	return x >> (n & mask$VALTYPECAP$$SHIFTYPECAP$)
}
`
	for _, valType := range value {
		capType := strings.Title(valType)
		capType = strings.Replace(capType, "Uint", "U", -1)
		capType = strings.Replace(capType, "Int", "I", -1)
		for _, shiftType := range shift {
			capShift := strings.Title(shiftType)
			capShift = strings.Replace(capShift, "Uint", "U", -1)
			capShift = strings.Replace(capShift, "Int", "I", -1)

			s := strings.Replace(template, "$VALTYPE$", valType, -1)
			s = strings.Replace(s, "$VALTYPECAP$", capType, -1)
			s = strings.Replace(s, "$SHIFTYPE$", shiftType, -1)
			s = strings.Replace(s, "$SHIFTYPECAP$", capShift, -1)
			f.WriteString(s)
		}
	}
}
